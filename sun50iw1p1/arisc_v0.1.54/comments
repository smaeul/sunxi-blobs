














































































; int cpucfg_set_power_switch(int enable);


; if (enable != 0) {



;     ptr = 0x01f01540 [R_PRCM_PWR_CLAMP_REG(0, 0)]
;     reg = *ptr
;     if (reg == 0) {


;         level = 2
;         msg = 0x00010960 "cpu%d power switch enable already"
;         goto print
;     }
;     reg = 0xfe
;     *ptr = reg
;     timer_udelay(20)

;     reg = 0xf8
;     *ptr = reg
;     timer_udelay(10)

;     reg = 0xe0
;     *ptr = reg
;     timer_udelay(10)

;     reg = 0xc0
;     *ptr = reg
;     timer_udelay(10)

;     reg = 0x80
;     *ptr = reg
;     timer_udelay(10)

;     reg = 0x0
;     *ptr = reg
;     timer_udelay(20)

;     while (*ptr != 0x0)
;         /* spin */



; } else {

;     ptr = 0x01f01540 [R_PRCM_PWR_CLAMP_REG(0, 0)]
;     reg = *ptr
;     if (reg == 0xff) {



;         msg = 0x00010983 "cpu%d power switch disable already"
;         level = 2
; print:  printf(level, msg, <missingno>)


;     } else {
;         reg = 0xff
;         *ptr = reg
;         timer_udelay(30)

;         while (*ptr != 0xff)
;             /* spin */

;     }
; }
; ret = 0

; return ret





; ptr3 = 0x00012260
; var2 = 0

; *ptr3 = var2

; ret = var2
; return ret





; ptr3 = 0x00012260
; var2 = 0

; *ptr3 = var2

; ret = var2
; return ret


; int cpucfg_set_ss_flag(void);


; ptr = 0x01f01da0 [R_CPUCFG_SS_FLAG_REG]
; flag = 0x16aaefe8
; ret = 0
; *ptr = flag

; flag = 0xaa16efe8
; *ptr = flag
; return ret


; int cpucfg_clear_ss_flag(void);

; flag = 0x16aa0000
; ptr = 0x01f01da0 [R_CPUCFG_SS_FLAG_REG]
; ret = 0
; *ptr = flag
; flag = 0xaa160000
; *ptr = flag
; return ret


; u32 cpucfg_get_status(u32 mpidr);
; mpidr >>= 2

; if (mpidr != 0)

;     ptr = 0x01700034 [CPUCFG_CPU_STS_REG(1)]
; else
;     ptr = 0x01700030 [CPUCFG_CPU_STS_REG(0)]
; ret = *ptr
; return ret














; msg = 0x000109a7 "no space for little-endian config"

































; int cpucfg_set_cpu_state(u32 cpu, int flag);
; cluster = cpu >> 2


; flag &= BIT(0) // 0 = assert, 1 = deassert
; if (cluster != 0) {

;     cpu -= 4
;     ptr = 0x01700084 [CPUCFG_RST_CTRL_REG(1)]
;     reg = *ptr
;     orig = reg

; } else {


;     ptr = 0x01700080 [CPUCFG_RST_CTRL_REG(0)]
;     reg = *ptr
;     orig = reg
; }

; ret = 0
; reg = BIT(cpu)
; new = flag << cpu
; mask = ~reg
; reg = mask & orig


; new |= reg


; *ptr = new
; return ret


; void cnt64_clear(void);


; ptr = 0x01f01e80 [CNT64_CTRL_REG]
; ret = 0
; reg = *ptr


; reg |= BIT(0)


; *ptr = reg
; return ret


; unsigned long long cnt64_read(void);


; ptr = 0x01f01e80 [CNT64_CTRL_REG]
; reg = *ptr


; reg |= BIT(1)


; *ptr = reg
; while (*ptr & BIT(1) != 0)
;     /* spin */



; loptr = 0x01f01e84 [CNT64_LOW_REG]
; hiptr = 0x01f01e88 [CNT64_HIGH_REG]
; loreg = *loptr

; hireg = *hiptr

; ret = hireg
; ret_hi = loreg
; return (unsigned long long) (ret_hi, ret)


; int cpucfg_set_ss_entry(u32 addr);

; ret = 0
; ptr = 0x01f01da8 [R_CPUCFG_SS_ENTRY_REG]
; *ptr = addr
; return ret


; void cpucfg_set_acinactm(u32 val);


; ptr = 0x01700004 [CPUCFG_CLS_CTRL_REG1(0)]

; reg = *ptr
; mask = ~BIT(0)

; val &= BIT(0)

; reg &= mask


; val |= reg


; *ptr = val

; return


; void cpucfg_wait_cluster_idle(void);

; ptr = 0x01700030 [CPUCFG_CPU_STS_REG(0)]
; do {var4 = *ptr
;     var4 &= BIT(0)
; } while (var4 == 0)


; return


; void cpucfg_set_l2rstdisable(u32 val);
; ptr = 0x01700000 [CPUCFG_CLS_CTRL_REG0(0)]

; reg = *ptr

; mask = 0xffffffe0

; val &= 0x0000001f

; reg &= mask


; val |= reg


; *ptr = val

; return


; void cpucfg_set_cluster_state(int enable);


; if (flag != 0)


;     if (flag != 1)
;         goto err



; if (enable == 0) {

;     ptr = 0x01700080 [CPUCFG_RST_CTRL_REG(0)]
;     mask = 0xfff0ffff
;     reg = *ptr


;     reg &= mask // assert undocumented reset


;     mask = 0xff0fffff

;     *ptr = reg
;     reg = *ptr


;     reg &= mask // assert MBIST_RST
;     m2 = 0xfffffff0


;     *ptr = reg

;     p2 = 0x01f01c30 [R_CPUCFG_PONRESET_REG(0)]
;     r2 = *p2


;     r2 &= m2 // assert cpu0-3 PONRESET


;     mask = ~BIT(24)

;     *p2 = r2
;     reg = *ptr // back to changing 0x01700080


;     reg &= mask // assert SOC_DBG_RST
;     mask = ~BIT(8)


;     *ptr = reg
;     reg = *ptr


;     reg &= mask // assert L2_RST
;     mask = ~BIT(12)


;     *ptr = reg
;     reg = *ptr


; DS  reg &= mask // assert HRESET
; } else {
;     mask = BIT(24)
;     ptr = 0x01700080 [CPUCFG_RST_CTRL_REG(0)]
;     reg = *ptr


;     reg |= BIT(12) // deassert HRESET


;     *ptr = reg
;     reg = *ptr


;     reg |= BIT(8) // deassert L2_RST


;     *ptr = reg
;     reg = *ptr


;     reg |= mask // deassert SOC_DBG_RST
;     mask = 0x00f00000


;     *ptr = reg

;     p2 = 0x01f01c30 [R_CPUCFG_PONRESET_REG(0)]
;     r2 = *p2


;     r2 |= BIT(0) // deassert cpu0 PONRESET


;     *p2 = r2
;     reg = *ptr // back to changing 0x01700080


;     reg |= mask // deassert MBIST_RST
;     mask = 0x000f0000


;     *ptr = reg
;     reg = *ptr


;     reg |= mask // deassert undocumented reset
; }

; *ptr = reg


; return

; err:

; msg = 0x000109ca "invalid cluster reset status"

; return printf(2, msg);


; void cpucfg_suspend_cluster(void);





; cpucfg_set_cpu_state(0, 0) // assert cpu0
; mask = ~BIT(0)

; ptr = 0x01f01c30 [R_CPUCFG_PONRESET_REG(0)]
; reg = *ptr


; reg &= mask // assert cpu0 PONRESET


; *ptr = reg
; cpucfg_set_acinactm(1) // disable snooping

; rtc_set_pwrstate(0x0000b000)

; cpucfg_wait_cluster_idle()

; rtc_set_pwrstate(0x0000b001)


; cpucfg_set_cpu_state(0, 0) // assert cpu0


; cpucfg_set_cpu_state(1, 0) // assert cpu1


; cpucfg_set_cpu_state(2, 0) // assert cpu2


; cpucfg_set_cpu_state(3, 0) // assert cpu3




; return rtc_set_pwrstate(0x0000b002)


; int cpucfg_disable_cluster(void);


; cpucfg_set_cluster_state(0)

; rtc_set_pwrstate(0x0000b003)


; cpucfg_func_00009c00(5, 1)


; cpucfg_func_00009c00(4, 1)

; rtc_set_pwrstate(0x0000b004)

; cpucfg_set_power_switch(0)



; return rtc_set_pwrstate(0x0000b005)


; int cpucfg_enable_cluster(void);


; cpucfg_set_power_switch(1)

; rtc_set_pwrstate(0x0000b006)


; cpucfg_func_00009c00(5, 0)


; cpucfg_func_00009c00(4, 0)

; rtc_set_pwrstate(0x0000b007)

; cpucfg_set_acinactm(0) // enable snooping

; rtc_set_pwrstate(0x0000b00a)


; cpucfg_set_cpu_state(0, 0) // assert cpu0

; rtc_set_pwrstate(0x0000b008)

; cpucfg_set_cluster_state(1)

; rtc_set_pwrstate(0x0000b009)



; return 0


; int cpucfg_resume_cpu0(void *entry);




; cpucfg_set_l2rstdisable(0)

; rtc_set_pwrstate(0x0000b00b)



; ptr = 0x01f01da8 [R_CPUCFG_SS_ENTRY_REG]
; *ptr = entry
; rtc_set_pwrstate(0x0000b00c)


; cpucfg_set_cpu_state(0, 3) // deassert cpu0

; rtc_set_pwrstate(0x0000b00d)


; ret = 0

; return ret

























































































; ptr = MC_MAER















; val = *MC_WORK_MODE
; udelay(1)


; [copy 32 bytes of DRAM to 0x12264]


; [starting at 0x40000000]












; [copy 32 bytes of DRAM to 0x122e4]
; [presumably the other channel...]

; [starting at 0x40004000]








; udelay(1)


; ptr = MC_MAER
; *MC_MAER = 0
; udelay(1)

; ptr = PWRCTL

; *PWRCTL |= BIT(8) | BIT(0)

; ptr = STATR



; while (*STATR & 7 != 3) {}

; ptr = PGCR0


; *PGCR0 &= ~GENMASK(27, 26)
; [possibly WDBVT/RDBVT]


; ptr = ACIOCR0


; *ACIOCR0 |= 0x40108


; ptr = DQSDR


; *DQSDR &= ~GENMASK(29, 28)
; [dunno what this does]

; ptr = DXnGCR0(0)

; *DXnGCR0(0) |= GENMASK(5, 4)
; [???]
; ptr = DXnGCR0(1)

; *DXnGCR0(0) |= GENMASK(5, 4)
; [???]
; ptr = ZQCR


; *ZQCR |= BIT(31) [enable ZQPD]

; udelay(10)


; ptr = VDD_SYS_PWROFF_GATING_REG
; val = *ptr
; val |= 3 (enable DRAM pad hold)
; *ptr = val
; udelay(10)



; *CLKEN = 0

; mask = ~BIT(31)
; ptr = PLL_DDR0_CTRL_REG
; val = *ptr
; val &= mask (disable PLL_DDR0)

; *ptr = val
; ptr = PLL_DDR1_CTRL_REG
; mask = ~BIT(31)
; val = *ptr
; val &= mask (disable PLL_DDR1)
; *ptr = val
; udelay(1)

; ptr = DRAM_CFG_REG

; val = *ptr
; mask = ~BIT(31)
; val &= mask (assert DRAM module reset)
; mask = BIT(16)
; *ptr = val
; val = *ptr
; val |= mask (set SDRCLK_UPD bit)
; mask = ~BIT(14)
; *ptr = val
; ptr = BUS_CLOCK_GATING_REG0
; ptr2 = BUS_RST_REG0
; val = *ptr
; val &= mask (disable DRAM bus clock)
; *ptr = val
; val = *ptr2
; val &= mask (assert DRAM bus reset)
; *ptr2 = val
; udelay(1)
























; msg = 0x000109e8 "dram standby code version 1.6"

















































































































































































































































































































































































































































































































































































































































































































































































































































; ptr = VDD_SYS_PWROFF_GATING_REG
; val = *ptr
; val &= ~3 (disable DRAM pad hold)
; *ptr = val
; udelay(10)






































































; msg = 0x00010a07 "DRAM training error,PGSR0 = %x"









































































; msg = 0x00010a27 "dram data write back start..."































; msg = 0x00010a47 "dram data write back end."













































































































; return rtc_set_pwrstate(0x00009007)













; return rtc_set_pwrstate(0x00009007)






































































; msg = 0x00010a63 "msgbox irq coming..."

































; msg = 0x00010a79 "inv msg[%x] rec"











































; msg = 0x00010a79 "inv msg[%x] rec"




















































































; if (var5 == 0) {



;     register_isr(17, hwmsgbox_isr, 0)

;     enable_axp_nmi_irq(17)
; }











































; msg = 0x00010a8a "send syn message : %x"






















; msg = 0x00010aa1 "hsyn msg err"





; msg = 0x00010aaf "hsyn msg[%x, %x] fb"

















; msg = 0x00010ac4 "send asyn or soft syn message : %x"



















; msg = 0x00010ae8 "message : %x finished"






































; msg = 0x00010aff "feedback hard syn message : %x"





























; msg = 0x00010ac4 "send asyn or soft syn message : %x"





































































; msg = 0x00010b1f "inv msg rec"




























































































; msg = 0x00010b2c "take hwspinlock%d timeout"

























































































; ptr3 = 0x01f00c00     // R_INTC_BASE
; ptr4 = 0x000123a4     // isr_list-0xc

; var2 = 0
; *ptr4 = ptr3
; *(ptr3 + 64) = var2   // INTC_EN_REG0 = 0
; mask = 0xffffffff
; *(ptr3 + 80) = var2   // INTC_MASK_REG0 = 0

; *(ptr3 + 16) = mask   // INTC_IRQ_PEND_REG0 = 0xffffffff

; ret = var2            // ret = 0
; return ret

















; var2 = arg1
; if (arg1 == 0) {




;     printf(1, msg)
;     msg = 0x00010b47 "clean NMI interrupt pending"

;     var4 = 1
;     ptr3 = 0x000123a4
;     ptr3 = *ptr3
;     *ptr3 = var4 // mmio_write32(R_INTC_BASE + 0x10, 1)
; }
; ptr3 = 0x000123a4
; ptr4 = *ptr3
; var3 = 1
; reg = *(ptr4 + 64) // R_INTC_BASE + 0x40
; set = var3 << var2 // set = BIT(arg1)
; reg |= set
; *(ptr4 + 64) = reg


; printf(var3, msg)
; msg = 0x00010b64 "intno:%d interrupt enable"



; return 0
















; u32 r_intc_current_irq(void)

; ptr3 = 0x000123a4     // r_intc_base
; ptr3 = *ptr3          // R_INTC_BASE
; ret = *ptr3           // readl(R_INTC_BASE + 0)
; return ret >> 2




; ret = r_intc_current_irq()



; msg = 0x00010b7f "irq [%x] enable before ISR install"
; printf(4, msg, ret)



; return 1


; void isr_list_init(void)















































; int register_isr(u32 index, u32 isr, u32 isr_arg);









; msg = 0x00010ba3 "install isr %x"

; printf(1, msg, isr_arg)

; offset = index << 3

; ret = 0
; base = 0x000123b0
; entry = offset + base
; entry->isr = isr
; entry->arg = isr_arg




; return ret


; int unregister_isr(u32 index, u32 isr);


; offset = index << 3
; base = 0x000123b0

; entry = offset + base
; old = entry->isr
; if (old == isr)



;     zero = 0
;     new = 0x000068a8 (isr_nop_warning)
;     entry->arg = zero
;     entry->isr = new
;     return 0



; printf(4, msg)
; msg = 0x00010bb3 "ISR not installed!"
; ret = -1


; return ret








; offset = ret << 3 // ret * sizeof(isr_list[0])
; base = 0x000123b0
; entry = offset + base
; fn = entry->isr
; fn(entry->arg)


; ret = 0

; return ret




















































































; msg = 0x00010bc7 "ir data full"
































































































































































; var5 = pmessage->paras[0] (ir_code)

; var3 = pmessage->paras[1] (ir_addr)
; var6 = 1

; ir_addr = var3

; ir_code = var5
; ir_en = var6


; msg = 0x00010bd5 "ir key:%x, addr:%x"





; return 0






















; msg = 0x00010be9 "read ir fifo raw data failed"



















; msg = 0x00010be9 "read ir fifo raw data failed"










































; msg = 0x00010c07 "lead1"







































; msg = 0x00010c0e "lead0"





















; msg = 0x00010c15 "Pulse %d"















; msg = 0x00010c1f "Distant %d"






















; msg = 0x00010c2b "%2x"


















































; msg = 0x00010c30 "detect valid ir code :%x"





; msg = 0x00010c4a "detect ir raw code :%x"



























; msg = 0x00010c62 "ir rx fifo full"






; msg = 0x00010c73 "inv ir rx irq det, st:0x%x"

















































































































































































































































































































































































































































































































































































































; msg = 0x00010c8f "invalid power voltage type[%u]"




















































































; msg = 0x00010c8f "invalid power voltage type[%u]"































; msg = 0x00010caf "invalid voltage value[%u] to set, type[%u], the reasonable range[%u-%u]"



























































































































































































; msg = 0x00010cf8 "NMI irq coming..."








; msg = 0x00010d0b "invalid nmi int type"












; msg = 0x00010d21 "allocate message for nmi int notify failed"





















































































; msg = 0x00010d4d "query pmu wakeup event"








; msg = 0x00010d65 "vbus"











; msg = 0x00010d6b "acin"











; msg = 0x00010d71 "battary full"












; msg = 0x00010d7f "bat temp"












; msg = 0x00010d89 "low battary"











; msg = 0x00010d96 "GPIO0 input edge"












; msg = 0x00010da8 "GPIO1 input edge"












; msg = 0x00010dba "long key"












; msg = 0x00010dc4 "short key"












; msg = 0x00010dcf "POK negative"











; msg = 0x00010ddd "POK postive"






; msg = 0x00010dea "event:%x"



























































; msg = 0x00010df4 "AW1660 IC_NO_REG value = %x"



























; register_isr(0, pmu_nmi_isr, 0)















































































































































































































; msg = 0x00010e11 "cfg pmu charge temp:%d, max_cur:%d"



















; msg = 0x00010e35 "cfg pmu temp safe range:0x%x ~ 0x%x"




























; msg = 0x00010e5a "bat_charge_temp:%d"


























; msg = 0x00010e6e "curr_set_ma:%d"




















; msg = 0x00010e7e "rel_curr_ma:%d"













; msg = 0x00010e8e "quan_c:%d"




































; msg = 0x00010e99 "temp_c:%d"














































; msg = 0x00010ea4 "adjust:%d"





; msg = 0x00010eaf "set cur:%x"

























































; msg = 0x00010ebb "mv:%x"


























; msg = 0x00010ec2 "mac:%x"






















; msg = 0x00010eca "mab:%x"



































; msg = 0x00010ed2 "power wakeup axp main reg10:%x"



















; msg = 0x00010ef2 "power wakeup axp main reg12:%x"





















; msg = 0x00010f12 "power wakeup axp main reg13:%x"





























; msg = 0x00010f32 "power wakeup axp main reg90:%x"




























; msg = 0x00010f52 "power wakeup axp main reg92:%x"




















































































; void rtc_set_pwrstate(u32 val);

; ptr = 0x01f0010c [R_RTC_GP_DATA_REG(3)]
; *ptr = val
; return


; u32 rtc_get_pwrstate(void);

; ptr = 0x01f0010c [R_RTC_GP_DATA_REG(3)]
; ret = *ptr
; return ret






































































; msg = 0x00010f72 "invaid module clock id (%d) when set source"












































; msg = 0x00010f9f "icd %x"














































































































; msg = 0x00010fa7 "invaid module clock id (%d) when set divider"























































































; msg = 0x00010fd5 "invaid module clock id (%d) when get divider"




































































































































; msg = 0x00010fa7 "invaid module clock id (%d) when set divider"




























































; msg = 0x00011003 "broadcast apb clock will change"




























; msg = 0x00011024 "broadcast apb clock change done"






































































































































































; msg = 0x00010f72 "invaid module clock id (%d) when set source"

































































































































; msg = 0x00011045 "invaid power control module (%d) when set power-off gating"
























; msg = 0x00011081 "broadcast 24mhosc will power-off"







; DEV_R_PRCM + R_PRCM_PLL_CTRL_REG1









; delay(20)






















































; msg = 0x000110a3 "broadcast 24mhosc power-on ready"

















































































































; msg = 0x000110c5 "invaid module clock id (%d) when set reset"

































































































































; msg = 0x000110f1 "PLL1 Freq %d N %d K %d M %d P %d"







; msg = 0x00011113 "invaid clock id (%d) when set freq"



















































































































; msg = 0x00011137 "invalid clock id for get source freq"


























; msg = 0x0001115d "rsb clk change request"

















; msg = 0x00011175 "rsb clk change done"




































; ptr3 = 0x01f0340c [R_RSB_STAT]

; var2 = *ptr3






; msg = 0x0001118a "loading busy"









; msg = 0x00011198 "rsb trans err[%x]"









































; msg = 0x000111ab "set rtsaddr failed, saddr:%x, rtsaddr:%x"









































; msg = 0x000111d5 "rsb set pmu mode failed"





































































; msg = 0x000111ee "write devaddr:%x, regaddr:%x, data:%x, datatype:%x"





















; msg = 0x00011222 "err datatype %d"


































; msg = 0x00011233 "rsb write failed"





; msg = 0x000111ee "write devaddr:%x, regaddr:%x, data:%x, datatype:%x"
















































; msg = 0x00011222 "err datatype %d"









; msg = 0x00011245 "data=0"






























; msg = 0x0001124d "rsb read failed"



; msg = 0x0001125e "read devaddr:%x, regaddr:%x, data:%x, datatype:%x"


























; msg = 0x0001125e "read devaddr:%x, regaddr:%x, data:%x, datatype:%x"





































































































































































































































































; msg = 0x00011291 "24m hosc will power-off notify"


































; msg = 0x000112b1 "24m hosc power-on ready notify"








































; entry = arg
; ptr18 = 0x000124cc

; ret = entry->index

; ptr3 = *ptr18
; ret = 1 << ret
; var3 = *(ptr3 + 4)


; ret &= var3

; if (ret != 0) {

;     fn = entry->callback
;     if (fn == NULL) {



;         printf(2, msg)
;         msg = 0x000112d1 "timer irq handler not install"
;         ret = 0
;     } else {
;         fn(entry->arg)

;         index = *entry
;         ptr3 = *ptr18
;         var2 = 1 << index
;         ret = 1
;         *(ptr3 + 4) = var2
;     }
; }



; return ret






; base = 0x1f00800
; ptr = 0x124cc

; *ptr = base


; clock_func_00009590(28, 1)


; clock_func_00009ef4(28, 1)


; base = *ptr
; ptr4 = 0x011d68
; var3 = 0

; var3 += 1
; var7 = 0
; var3 <<= 5 (var3 = 0x20)
; mask8 = 0xfffffff3

; ptr3 = base + var3
; *ptr4 = ptr3
; *ptr3 = 0
; var7 = *ptr3
; var7 &= mask8 (&= 0xfffffff3)
; mask8 = 0xffffff8f
; *ptr3 = var7
; var7 = *ptr3
; var7 |= BIT(2)
; *ptr3 = var7
; var7 = *ptr3
; var7 &= mask8 (&= 0xffffff8f)
; *ptr3 = var7
; var7 = *ptr3
; *ptr3 = var7




































; int timer_register_callback(void (*fn)(uint32_t), uint32_t arg)






; ptr2 = 0x00011d50
; var16 = fn
; ret = disable_interrupts()
; var14 = arg
; var5 = *(ptr2 + 4)            // *0x11d54
; if (var5 != 0) {

;     // array of two 28-byte structures
;     var3 = *(&ptr2[1] + 4)    // *0x11d70
;     var2 = 0
;     if (var3 != 0)
;         goto next
;     var5 = 1  // DS
; }

; offset = var5 * 28

; ptr3 = 0x00011d50
; entry = ptr3 + offset

; entry->callback = fn
; entry->used = 1
; entry->arg = arg
; next: restore_interrupts(ret)

; if (entry == NULL) { // goto next was taken



;     printf(2, msg)
;     msg = 0x000112f0 "no free timer now"

; } else {



;     register_isr(entry->isr_idx, timer_isr, entry)

; }
; ret = entry



































































































































































; void timer_udelay(u32 usecs);




; if (usecs == 0)
;     return

; (time_hi, time_lo) = cnt64_read()
; end_hi = 1
; // arg0 * 2
; // arg0 * 3
; cycles = usecs * 24
; end_lo = time_lo + cycles
; if (end_lo >= time_lo)


;     end_hi = 0
; end_hi += time_hi
; do {
;     (time_hi, time_lo) = cnt64_read()
; } while (end_hi > time_hi ||
;         (end_hi == time_hi &&
;             end_lo > time_lo))







; return























































































; int r_uart_putc(char c);


; ptr4 = 0x00011d88
; ret = -1
; var4 = *ptr4
; if (var4 != 0)
;     return ret
; c = (char) c

; ptr4 = 0x00011f7c
; var4 = *ptr4
; if (var4 != 0)
;     return ret

; ptr4 = 0x01f0287c [R_UART_USR]
; while ((*ptr4 & BIT(1)) == 0)
;     /* spin */




; ret = 0
; ptr4 = 0x01f02800 [R_UART_THR]
; *ptr4 = c
; return ret


; int r_uart_gets(char *buf);

; ret = -1
; ptr4 = 0x00011d88
; var4 = *ptr4
; if (var4 != 0)
;     return ret


; ptr4 = 0x00011f7c
; var4 = *ptr4
; if (var4 != 0)
;     return ret

; ret = var4 [ret = 0]

; ptr5 = 0x01f02884 [R_UART_RFL]
; for (ptr4 = 0x01f02800; var6; var6 = *ptr5)
;     ptr6 = &buf[ret]
;     var7 = *ptr4
;     ret += 1
;     *(char *)ptr6 = r7



; DOES NOT NULL TERMINATE
; return ret


; int r_uart_puts(char *str)

; ptr2 = str


; ptr3 = 0x00011d88

; var3 = *ptr3
; if (var3 != 0)
;     return ret
; DS ret = -1

; ptr3 = 0x00011f7c
; var3 = *ptr3
; if (var3 != 0)


;     return ret

; while ((ret = *(char *)ptr2) != '\0')
;     if (ret == '\n')
;         r_uart_putc('\r')


;     r_uart_putc(*(char *)ptr2)
;     ptr2 += 1






; return ret

















; msg = 0x00011303 "uart buadrate change from [%d] to [%d]"




















































































; msg = 0x0001132b "uart source clock change request"




















; msg = 0x0001134d "uart buadrate change done"















; void delay(u32 cycles);
; while (cycles-- != 0)
;     /* spin */

; cycles += 1
; return























































































































































; msg = 0x00011368 "%s :"










; msg = 0x0001136e " 0x%8x :"





; msg = 0x00011378 "%8x"

















; int strlen(char *str);
; end = str
; do {

;     end += 1
; } while ((c = *(char *)end) != 0)
; end -= 1
; return end - str


; char *strcpy(char *s1, char *s2);
; off = 0
; do {p2 = s2 + off
;     p1 = s1 + off
;     c = *p2
;     *p1 = c

;     off += 1
; } while (c != '\0')
; return s1

















































































































































































































; msg = 0x0001137d "freq   :%d"





; msg = 0x00011389 "voltage:%d"





; msg = 0x00011395 "axi_div:%d"














































; msg = 0x000113a1 "dvfs try to increase voltage failed"



















; msg = 0x000113c6 "current voltage != target voltage"



















































; msg = 0x000113e9 "dvfs try to decrease voltage failed"


















; msg = 0x0001140e "DVFS succeed, freq = %u, voltage = %u, axi_div = %u"
















































































































; msg = 0x00011443 "fn:%x,arg:%x"

































; msg = 0x00011451 "standby power check enable:0x%x, regs:0x%x, sys_power:%d"





















; void dram_set_crc_paras(u32 en, u32 srcaddr, u32 len);


; ptr = 0x000121cc
; *ptr = en

; ptr = 0x00011db0
; *ptr = srcaddr

; ptr = 0x00011db4
; return
; DS *ptr = len

; u32 dram_get_crc_enabled(void);

; ptr = 0x000121cc
; return *ptr












; msg = 0x0001148b "crc begin..."








; msg = 0x00011499 "src:%x len:%x"
















; msg = 0x000114a8 "crc finish..."






























; msg = 0x000114b7 "stack free:%dbyte"





















; u32 disable_interrupts(void);

; mask = 0xfffffff9
; addr = SPR_SR

; old = read_spr(addr)
; new = old & mask
; write_spr(addr, new)

; return old


; void restore_interrupts(u32 value);
; addr = SPR_SR
; write_spr(addr, value)
; return void


; __noreturn void exit(void);




; printf(8, msg)
; msg = 0x000114ca "system exit"
; loop


; void exception_handler(u32 number, u32 pc, u32 *regs);




; if (number != 8) // external interrupt
;     unknown_exception(number, pc, regs) // noreturn




; return irq_handler()


; void unknown_exception(u32 number, u32 pc, u32 *regs);



; ptr = 0x00011dd4 <array of char* exception types>





; msg = 0x000114d7 "exception [%x, %s] coming, [epc = %x]"




; msg = 0x000114fe "register list:"





; msg = 0x0001150e "register%x: %x"










; msg = 0x0001151e "cpu abort enter..."

; loop














































; u32 get_0x121e4(void);

; ptr3 = 0x000121e4
; ret = *ptr3
; return ret























; timer_register_callback(timer_isr_callback, 0)


















; msg = 0x00011618 "setup timer server succeeded"



































; msg = 0x00011636 "debugger system ok"





; msg = 0x0001164a "rsb driver ok"





; msg = 0x00011659 "pmu driver ok"





; msg = 0x00011668 "hwspinlock driver ok"





; msg = 0x0001167e "hwmsgbox driver ok"





; msg = 0x00011692 "message manager ok"





; msg = 0x000116a6 "cpucfg driver ok"





; msg = 0x000116b8 "timer driver ok"





; msg = 0x000116c9 "dvfs service driver ok"





; msg = 0x000116e1 "standby service ok"





; msg = 0x000116f5 "time ticks ok"



; msg = 0x00011704 "watchdog ok"








; msg = 0x00011711 "allocate message for init fb failed"





; msg = 0x00011736 "feedback startup result [%d]"















; msg = 0x00011754 "v0.1.54"













; msg = 0x0001175c "startup feedback ok"




; msg = 0x00011771 "ar100 firmware version : %d"







; msg = 0x0001178e "daemon service setup..."

































































; msg = 0x00010924 "arisc_para_get_message_pool_info"



; msg = 0x000117a7 "%s: %x %x"











; ptr = 0x000124f4
; return *(ptr + 0x10)














; msg = 0x000117b2 "" <whitespace>



























; return 0



; return 0


; int putc(char c);



; r_uart_putc((char) c)



; return 0


; int gets(char *buf);




; return r_uart_gets(buf)


; int puts(char *str);

; r_uart_puts(str)



; return 0


; int printf(u32 mask, char *fmtstr, ...);



; ptr2 = 0x00011e14

; ret = *ptr2
; var2 = 240
; ret += 1

; ret = var2 >> ret




; ret &= mask

; if (ret == 0)
;     return ret
; fmtstr = arg1
; ret = disable_interrupts()

; ptr2 = 0x00011e18
; var22 = ret
; var2 = *ptr2

; if (var2 != 0) {

;     ret = get_0x121e4()
;     var2 = 91

























































; }

; str = 0x0001266c
; while ((fmt = *fmtstr) != 0) {
;     if (fmt == '%') {

















































































;     } else {
;         *str = fmt
;         str += 1
;         fmtstr += 1
;     }


; }














; puts(0x0001266c)

; restore_interrupts(var22)

; ptr3 = 0x0001266c

; ret = str - ptr3








; return ret


; int set_debug_mask(u32 mask);



; debug_mask_ptr = 0x00011e14



; new_mask = mask
; old_mask = *debug_mask_ptr
; msg = 0x000117c3 "debug_mask from %d to %d"


; printf(8, msg, old_mask, new_mask)

; *debug_mask_ptr = new_mask

; ret = 0


; return ret




; ptr = 0x000121f4
; var4 = *ptr
; if (arg0 < var4)
;     return 0
; ret = 0

; ptr = 0x000121f8
; var5 = *ptr
; if (arg0 < var5)
;     return 1


; ret = 0
; return ret



















; msg = 0x000117dd "%s: message pool addr=%x, size=%x"







































































; msg = 0x00011800 "message [%x] alloc from cache"





; msg = 0x0001181f "message_cache num:%x"




























; msg = 0x00011835 "message alloc from pool"
















; msg = 0x0001184e "allocate message invalid, add:%p"































; msg = 0x00011870 "free invalid message"














; msg = 0x00011886 "message [%x] insert to message_cache"





; msg = 0x000118ac "message_cache number:%x"











































; msgptr = addr



; msg = 0x000118c5 "MESSAGE FROM AC327"














; msg = 0x000118d9 "attr:%x"








; ARISC_SET_DEBUG_LEVEL (96)


; binary search with delay slot below


; ARISC_AXP_DISABLE_IRQ (81)

; binary search with delay slot below


; ARISC_STANDBY_INFO_REQ (32)

; ARISC_CPUX_DVFS_REQ (48)

; invalid

; ARISC_ESSTANDBY_ENTER_REQ (22)
; --------------------------------------------
; ARISC_AXP_GET_CHIP_ID (83 from delay slot)

; ARISC_AXP_ENABLE_IRQ (82 (<83 but >81))


; invalid

; ARISC_AXP_SET_PARAS (84)
; --------------------------------------------
; ARISC_SET_IR_PARAS (101)

; binary search with delay slot below


; ARISC_SET_UART_BAUDRATE (98)

; ARISC_MESSAGE_LOOPBACK (97 (<98 but >96))


; invalid

; ARISC_SET_DEBUG_DRAM_CRC_PARAS (100)
; --------------------------------------------
; ARISC_RSB_WRITE_BLOCK_DATA (129)

; ARISC_RSB_BITS_OPS_SYNC (130)

; invalid

; ARISC_RSB_READ_BLOCK_DATA (128)
; --------------------------------------------



; msg = 0x000118e2 "cpux dvfs request"



; --------------------------------------------

; msg = 0x000118f5 "esstandby enter request"
























; msg = 0x0001190e "copy esstandby code"


; rtc_set_pwrstate(0xf3f30000)




; --------------------------------------------



; msg = 0x00011923 "set ir paras request"



; --------------------------------------------



; msg = 0x00011939 "standby info request"



; --------------------------------------------



; msg = 0x0001194f "disable axp irq request"



; --------------------------------------------


; msg = 0x00011968 "enable axp irq request"





; --------------------------------------------



; msg = 0x00011980 "axp get chip id request"
; axp_get_chip_id(msgptr)


; --------------------------------------------

; msg = 0x00011999 "pmu set paras request"
; pmu_set_params(msgptr)


; --------------------------------------------

; msg = 0x000119b0 "read pmu register request"
; rsb_read_pmu_reg(msgptr)


; --------------------------------------------



; msg = 0x000119cb "write pmu register request"
; rsb_write_pmu_reg(msgptr)


; --------------------------------------------



; msg = 0x000119e7 "rsb bits ops request"



; --------------------------------------------



; msg = 0x000119fd "set debug level request"



; --------------------------------------------



; msg = 0x00011a16 "set uart baudrate request"



; --------------------------------------------

; msg = 0x00011a31 "set dram crc paras request"


; dram_set_crc_paras(pmessage->paras[0],
;     pmessage->paras[1], pmessage->paras[2])

; --------------------------------------------

; msg = 0x00011a4d "loopback message request"







; msg = 0x00011a67 "invalid message type [%x]"













































































































; msg = 0x00011a82 "allocate notifier failed"






















































; int ???(??? *arg0, ??? arg1, ??? arg2);




; var16 = arg1

; var14 = arg2
; ptr = *arg0
; while (ptr != NULL) {
;     funcptr = *(ptr + 4)
;     (*funcptr)(arg1, arg2)

;     ptr = *(ptr + 8)


; }

; ret = 0



; return ret


; void icache_flush(void);






; step = 16
; addr = 0
; limit = 4096
; do {
;     <invalidate icache at addr>
; } while ((addr += step) != limit)









































; reg = 1
; reg |= 80
; spr[0, 0x11] = reg  // SPR[SR] = 0x00000081
; spr[10, 0x0] = 0x00000000 // SPR[TTMR] = 0

; reg = 0x12b00
; mask = 0xfffffffd
; reg &= mask   // Set stack pointer
; reg6 = spr[0, 0x11]  // SPR[SR]
; mask = 0xffffffff
; mask ^= 0x10   // = 0xffffffef
; reg5 = reg6 & mask // Disable icache
; spr[0, 0x11] = reg5  // SPR[SR] &= ~0x10
; var14 = 0x10
; reg6 = 0
; reg5 = 0x1000
; do { spr[4, 0x02] = reg6 // SPR[ICBIR] = 0

;     reg6 += 0x10
; } while (reg6 != reg5) // Clear icache











; // Clear .bss
; ptr5 = 0x11e20

; ptr6 = 0x12700








































































































































































































































































































































































































































; rtc_set_pwrstate(0xf3f31000)










; rtc_set_pwrstate(0xf3f31001)




























; msg = 0x00010114 "%x enter"





; rtc_set_pwrstate(0xf3f32000)

; rtc_set_pwrstate(0xf3f33001)




















; rtc_set_pwrstate(0xf3f33002)





; rtc_set_pwrstate(0xf3f33003)




; rtc_set_pwrstate(0xf3f33004)
















; cpucfg_func_00009c00(14, 1)


; rtc_set_pwrstate(0xf3f33005)







; rtc_set_pwrstate(0xf3f33006)









































; rtc_set_pwrstate(0xf3f33007)






; rtc_set_pwrstate(0xf3f33008)




; rtc_set_pwrstate(0xf3f33009)





























; disable PLL_CPUX






















































































































































































































































































































































































































































































































































































































; finally done disabling clocks!

















; key = 0xa7000000

; ptr = DEV_R_PRCM + R_PRCM_PLL_CTRL_REG1
; mask = ~GENMASK(1, 0)
; val = *ptr
; val |= key


; *ptr = val
; val = *ptr
; val |= key


; val &= mask


; *ptr = val



; rtc_set_pwrstate(0xf3f3300a)







; cpucfg_func_00009c00(15, 1)


; cpucfg_func_00009c00(17, 1)


; cpucfg_func_00009c00(18, 1)









; cpucfg_func_00009c00(19, 1)













; rtc_set_pwrstate(0xf3f3300b)




















































































; rtc_set_pwrstate(0xf3f3300c)



; rtc_set_pwrstate(0xf3f34000)












; msg = 0x0001011e "estif"















































; msg = 0x00010125 "wait wakeup event coming"




; rtc_set_pwrstate(0xf3f35000)






























































; msg = 0x0001013f "pin wakeup detect"






















; msg = 0x00010152 "cir wakeup detect"






















































; msg = 0x00010165 "USB EHCI0 wakeup"







; msg = 0x00010177 "USB otg wakeup detect"














; msg = 0x0001018e "USB wakeup detect"



































; rtc_set_pwrstate(0xf3f36000)






; rtc_set_pwrstate(0xf3f37001)
































































; rtc_set_pwrstate(0xf3f37002)






; cpucfg_func_00009c00(15, 0)


; cpucfg_func_00009c00(17, 0)


; cpucfg_func_00009c00(18, 0)








; cpucfg_func_00009c00(19, 0)
















; rtc_set_pwrstate(0xf3f37003)



































































































































































































































































































































































































































; rtc_set_pwrstate(0xf3f37004)




; rtc_set_pwrstate(0xf3f37005)



















; udelay(100)


















; rtc_set_pwrstate(0xf3f3900f)




; msg = 0x000101a1 "dram crc error..."




; rtc_set_pwrstate(0xf3f37006)







; rtc_set_pwrstate(0xf3f37007)













; cpucfg_func_00009c00(14, 0)





; rtc_set_pwrstate(0xf3f37008)









; rtc_set_pwrstate(0xf3f37009)





; rtc_set_pwrstate(0xf3f3700a)





; rtc_set_pwrstate(0xf3f3700b)























; msg = 0x000101b4 "esstandby ignore message [%x, %x]"




















; rtc_set_pwrstate(0xf3f3700c)





; rtc_set_pwrstate(0xf3f3700d)


; rtc_set_pwrstate(0xf3f38000)










; msg = 0x000101d7 "%x return"
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































